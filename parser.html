<!DOCTYPE html>
<html>

<head>
  <title>x1337_api_script</title>
  <meta charset="UTF-8" />
</head>

<body>
  <h1>x1337_api_script server working</h1>
  <script>
    // Basic name-based NSFW heuristic
    function isNSFW(name) {
      if (!name) return false;
      const s = String(name).toLowerCase();
      const patterns = [
        'porn', 'xxx', 'sex', 'hentai', 'nsfw', 'adult', 'erotic', 'hardcore',
        'xvideos', 'xnxx', 'jav', 'idol', 'brazzers', 'bangbros', 'pornhub', 'masturbate',
        /\b18\+\b/,
      ];
      return patterns.some(p => (p instanceof RegExp ? p.test(s) : s.includes(p)));
    }

    // ---- Decode helpers ----
    function normalizeBase64(b64) {
      if (typeof b64 !== 'string') return '';
      let s = b64.replace(/-/g, '+').replace(/_/g, '/');
      const pad = s.length % 4;
      if (pad) s += '='.repeat(4 - pad);
      return s;
    }

    function decodeBase64UTF8(base64String) {
      const s = normalizeBase64(base64String);
      const binaryString = atob(s);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
      return new TextDecoder('utf-8').decode(bytes);
    }

    function base64EncodeUtf8(str) {
      const bytes = new TextEncoder().encode(str);
      let binary = '';
      for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary);
    }

    class Snowfl {
      // ===== Helpers =====
      substringBetween(text, startDelimiter, endDelimiter) {
        if (typeof text !== 'string') return '';
        const startIndex = text.indexOf(startDelimiter);
        if (startIndex === -1) return '';
        const endIndex = text.indexOf(endDelimiter, startIndex + startDelimiter.length);
        if (endIndex === -1) return '';
        return text.substring(startIndex + startDelimiter.length, endIndex);
      }

      generateRandomString(length) {
        const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        const cryptoObj = globalThis.crypto;
        if (cryptoObj?.getRandomValues) {
          const values = new Uint32Array(length);
          cryptoObj.getRandomValues(values);
          return Array.from(values).map(v => charset[v % charset.length]).join('');
        }
        return Array.from({ length }, () => charset[Math.floor(Math.random() * charset.length)]).join('');
      }

      // ---- Fetch & extract token from b.min.js ----
      async setInitVariable(baseUrl) {
        try {
          if (!baseUrl) throw new Error('baseUrl is required');
          if (!window.flutter_inappwebview?.callHandler) throw new Error('flutter_inappwebview not available');

          const jsUrl = new URL('b.min.js', baseUrl).toString();
          const raw = await window.flutter_inappwebview.callHandler('curlRequest', {
            url: jsUrl,
            method: 'GET',
            runInIsolate: true,
          });

          // curlRequest: { data: base64Encode(utf8.encode(response?.data ?? "")), statusCode }
          const data = decodeBase64UTF8(raw.data);
          if (!data) return { apiTokenForSnowFl: '' };

          let variableName = this.substringBetween(data, 'x="/"+', '+');
          if (!variableName) {
            const m = data.match(/([$_A-Za-z][$_A-Za-z0-9]*)\s*=\s*"([^"]+)";/);
            if (m) variableName = m[1];
          }

          let apiTokenForSnowFl = '';
          if (variableName) {
            apiTokenForSnowFl = this.substringBetween(data, `${variableName}="`, '";');
          }
          if (!apiTokenForSnowFl) {
            const m2 = data.match(/=["']([A-Za-z0-9._-]{8,})["'];?/);
            if (m2) apiTokenForSnowFl = m2[1];
          }

          return { apiTokenForSnowFl: apiTokenForSnowFl || '' };
        } catch {
          return { apiTokenForSnowFl: '' };
        }
      }

      // ---- Search endpoint ----
      async search(options) {
        try {
          const query = (options?.query && options.query.length) ? options.query : 'Q';
          const searchSiteModelData = JSON.parse(options?.searchSiteModel || '{}');
          const globalVariablesData = JSON.parse(options?.globalVariables || '{}');

          const baseUrl = searchSiteModelData.primarySource || '';
          const apiToken = globalVariablesData.apiTokenForSnowFl || '';
          if (!baseUrl || !apiToken) throw new Error('unable to get data');

          const randomTail = this.generateRandomString(8) + '/0/DATE/NONE/1';
          const path = encodeURIComponent(apiToken) + '/' + encodeURIComponent(query) + '/' + randomTail;

          const baseWithSlash = baseUrl.endsWith('/') ? baseUrl : (baseUrl + '/');
          let urlStr = new URL(path, baseWithSlash).toString();
          urlStr += (urlStr.includes('?') ? '&' : '?') + '_=' + Date.now();

          const result = await window.flutter_inappwebview.callHandler('curlRequest', {
            url: urlStr,
            method: 'GET',
            runInIsolate: true
          });

          const decodedText = decodeBase64UTF8(result.data);
          const raw = JSON.parse(decodedText);

          const apiData = [];
          if (Array.isArray(raw)) {
            for (const item of raw) {
              if (item && item.nsfw !== true) {
                if (typeof item.magnet === 'string') {
                  item.magnet = [item.magnet];
                  if (item.url) item.magnet.push(item.url);
                } else if (Array.isArray(item.magnet)) {
                  if (item.url) item.magnet.push(item.url);
                } else {
                  item.magnet = [];
                }
                item.parentSite = "https://snowfl.com";
                apiData.push(item);
              }
            }
          }
          return apiData;
        } catch {
          throw new Error('unable to get data');
        }
      }

      // ---- Get Info ----
      async getInfo(url, baseUrl, torrentSearchModel, globalVariables) {
        try {
          const torrentSearchModelData = JSON.parse(torrentSearchModel || '{}');
          const globalVariablesData = JSON.parse(globalVariables || '{}');

          const site = torrentSearchModelData.site || '';
          const siteUri = torrentSearchModelData.url || '';
          const apiToken = globalVariablesData.apiTokenForSnowFl || '';
          if (!baseUrl || !apiToken) return { magnet: [] };

          const uri = encodeURIComponent(siteUri || '');
          const base64Str = base64EncodeUtf8(uri);

          const baseWithSlash = baseUrl.endsWith('/') ? baseUrl : (baseUrl + '/');
          const api = `${baseWithSlash}${apiToken}/${site}/${base64Str}?_=${Date.now()}`;

          const result = await window.flutter_inappwebview.callHandler('curlRequest', {
            url: api,
            method: 'GET',
            runInIsolate: true
          });

          const body = decodeBase64UTF8(result.data);
          const parsed = JSON.parse(body);

          // Return both parsed.url and siteUri as requested
          const magnetArr = [];
          if (parsed?.url) magnetArr.push(parsed.url);
          if (siteUri) magnetArr.push(siteUri);

          return { magnet: magnetArr };
        } catch {
          return { magnet: [] };
        }
      }
    }

    class RarbgDump {
      static absoluteUrl(base, href) {
        try {
          return new URL(href, base).toString();
        } catch {
          return href || '';
        }
      }

      // ===== Main search =====
      async search(options) {
        const callHandler = window.flutter_inappwebview?.callHandler;
        if (!callHandler) throw new Error('flutter_inappwebview not available');

        try {
          // Parse site model
          const searchSiteModelData = JSON.parse(options?.searchSiteModel || '{}');

          const base = searchSiteModelData.primarySource || 'https://rarbgdump.com';
          const searchPath = searchSiteModelData.searchPath || '/search/{SEARCH_QUERY}';
          const query = (options?.query && options.query.length) ? options.query : 'book';

          // replace {SEARCH_QUERY} in searchPath
          const path = searchPath.replace('{SEARCH_QUERY}', encodeURIComponent(query));
          const url = new URL(path, base).toString();

          const res = await callHandler('curlRequest', {
            url,
            method: 'GET',
            runInIsolate: true
          });

          const html = decodeBase64UTF8(res?.data);
          if (!html) return [];

          // Parse HTML
          const doc = new DOMParser().parseFromString(html, 'text/html');

          const tbody =
            doc.querySelector('tbody[class*="[_tr:last-child]:border-0"]') ||
            doc.querySelector('tbody[class*="border-0"]') ||
            doc.querySelector('tbody');

          if (!tbody) return [];

          const rows = Array.from(tbody.querySelectorAll('tr'));
          const results = [];

          for (const tr of rows) {
            const tds = tr.querySelectorAll('td');
            if (tds.length < 5) continue;

            // 2nd TD -> name + url
            const tdName = tds[1];
            const aName = tdName.querySelector('a');
            const name = (tdName.textContent || '').trim();
            const urlRel = aName?.getAttribute('href') || '';
            const itemUrl = RarbgDump.absoluteUrl(base, urlRel);

            // 3rd TD -> magnet <a>
            const tdMagnet = tds[2];
            const magnetA = tdMagnet.querySelector('a[href^="magnet:"]');
            const magnetLink = magnetA?.getAttribute('href') || '';

            // 4th TD -> size
            const size = (tds[3].textContent || '').trim();

            // 5th TD -> type
            const type = (tds[4].textContent || '').trim();

            // Build magnet list
            const magnetList = [];
            if (magnetLink) magnetList.push(magnetLink);
            if (itemUrl) magnetList.push(itemUrl);

            const nsfw = isNSFW(name);

            results.push({
              magnet: magnetList,
              source: searchSiteModelData.key || 'rarbgdump',
              age: "",
              name,
              size,
              seeder: "",
              leecher: "",
              type,
              site: searchSiteModelData.siteTitle || 'RARBG',
              parentSite: searchSiteModelData.primarySource || 'https://rarbgdump.com',
              url: itemUrl,
              trusted: true,
              description: "",
              nsfw
            });
          }

          return results;
        } catch {
          throw new Error('unable to get data');
        }
      }
    }

    class FilePursuit {
      static absoluteUrl(base, href) {
        try {
          return new URL(href, base).toString();
        } catch {
          return href || '';
        }
      }

      static extractClipboardUrl(onclickVal) {
        if (!onclickVal) return '';
        const m = onclickVal.match(/copyToClipboard\(['"]([^'"]+)['"]\)/i);
        return m ? m[1] : '';
      }

      async search(options) {
        const callHandler = window.flutter_inappwebview?.callHandler;
        if (!callHandler) throw new Error('flutter_inappwebview not available');

        try {
          const searchSiteModelData = JSON.parse(options?.searchSiteModel || '{}');

          const base = searchSiteModelData.primarySource || 'https://filepursuit.com';
          const searchPath =
            searchSiteModelData.searchPath ||
            '/pursuit?q={SEARCH_QUERY}&type=all&sort=datedesc';
          const query =
            options?.query && options.query.length ? options.query : 'Flutter book';

          let path = searchPath;
          if (path.includes('{SEARCH_QUERY}')) {
            path = path.replace('{SEARCH_QUERY}', encodeURIComponent(query));
          } else if (!/[?&]q=/.test(path)) {
            const sep = path.includes('?') ? '&' : '?';
            path = `${path}${sep}q=${encodeURIComponent(query)}`;
          }
          const url = new URL(path, base).toString();

          const res = await callHandler('curlRequest', {
            url,
            method: 'GET',
            runInIsolate: true
          });

          const html = decodeBase64UTF8(res?.data);
          if (!html) return [];

          const doc = new DOMParser().parseFromString(html, 'text/html');

          const allRows = Array.from(doc.querySelectorAll('div.row'));
          const resultRows = allRows.filter(
            r => r.querySelector('h5') && r.querySelector('.mr-3.wrap-tight')
          );

          const items = [];

          for (const row of resultRows) {
            const h5 = row.querySelector('h5');
            const name = (h5?.textContent || '').trim();

            const firstA = row.querySelector('a[href]');
            const pageHref = firstA?.getAttribute('href') || '';
            const itemUrl = FilePursuit.absoluteUrl(base, pageHref);

            const badgeWrap = row.querySelector('.mr-3.wrap-tight');
            const spans = badgeWrap ? Array.from(badgeWrap.querySelectorAll('span')) : [];

            const type = spans.length > 0 ? (spans[0].textContent || '').trim() : '';
            const age = spans.length > 1 ? (spans[1].textContent || '').trim() : '';
            const size = spans.length > 2 ? (spans[spans.length - 1].textContent || '').trim() : '';

            const badgeCopy = row.querySelector('.badge-wrap a[onclick*="copyToClipboard"]');
            const directLink = FilePursuit.extractClipboardUrl(
              badgeCopy?.getAttribute('onclick') || ''
            );

            const magnet = [];
            if (directLink) magnet.push(directLink);
            if (itemUrl) magnet.push(itemUrl);

            items.push({
              magnet,
              source: searchSiteModelData.key || 'filepursuit',
              age,
              name,
              size,
              seeder: "",
              leecher: "",
              type,
              site: searchSiteModelData.siteTitle || 'FilePursuit',
              parentSite: searchSiteModelData.primarySource || 'https://filepursuit.com',
              url: itemUrl,
              trusted: true,
              description: "",
              nsfw: (typeof isNSFW === 'function') ? !!isNSFW(name) : false
            });
          }

          return items;
        } catch {
          throw new Error('unable to get data');
        }
      }
    }

    class Odcrawler {
      async search(options) {
        const callHandler = window.flutter_inappwebview?.callHandler;
        if (!callHandler) throw new Error("flutter_inappwebview not available");

        try {
          const searchSiteModelData = JSON.parse(options?.searchSiteModel || "{}");
          const query =
            options?.query && options.query.length ? options.query : "test";

          const apiUrl = "https://search.odcrawler.xyz/elastic/links/_search";

          // Build request body
          const body = {
            size: 40,
            from: 0,
            highlight: {
              fields: {
                url: {},
                filename: {},
              },
            },
            query: {
              bool: {
                must: [
                  {
                    match_phrase: { url: query },
                  },
                ],
                should: [
                  {
                    match_phrase: { filename: query },
                  },
                ],
                must_not: [
                  {
                    terms: {
                      extension: ["html", "HTML"],
                    },
                  },
                ],
              },
            },
          };

          // Make POST request
          const res = await callHandler("curlRequest", {
            url: apiUrl,
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(body),
            runInIsolate: true,
          });

          const decodedText = decodeBase64UTF8(res?.data);
          if (!decodedText) return [];

          const json = JSON.parse(decodedText);
          const hits = json?.hits?.hits || [];

          const items = hits.map((hit) => {
            const src = hit?._source || {};
            const url = src.url || "";
            const filename = src.filename || "";
            const extension = src.extension || "";

            return {
              magnet: url ? [url] : [],
              source: searchSiteModelData.key || "odcrawler",
              age: "",
              name: filename,
              size: "",
              seeder: "",
              leecher: "",
              type: extension,
              site: searchSiteModelData.siteTitle || "Odcrawler",
              parentSite:
                searchSiteModelData.primarySource || "https://odcrawler.xyz",
              url,
              trusted: true,
              description: "",
              nsfw:
                typeof isNSFW === "function"
                  ? !!isNSFW(filename || url)
                  : false,
            };
          });

          return items;
        } catch (e) {
          throw new Error("unable to get data");
        }
      }
    }


    class CseGoogle {
      parseSuggestions(responseText) {
        if (typeof responseText !== 'string' || !responseText.length) return [];

        // Strip JSONP callback wrapper: google.sbox.pXX(...)
        let jsonStr = responseText.replace(/^.*?\(/, "").replace(/\);?$/, "");

        // Strip potential XSSI prefix )]}'
        jsonStr = jsonStr.replace(/^\)\]\}'\s*/, "");

        try {
          const data = JSON.parse(jsonStr);
          const arr = Array.isArray(data?.[1]) ? data[1] : [];
          return arr.map(item => (Array.isArray(item) ? item[0] : item)).filter(Boolean);
        } catch {
          return [];
        }
      }

      async fetchSuggestions(query) {
        try {
          if (!query) return [];
          const url =
            `https://clients1.google.com/complete/search` +
            `?client=partner-web&hl=en&partnerid=50c5ac9923f4a4b9b&types=t&ds=cse&q=${encodeURIComponent(query)}`;

          if (!window.flutter_inappwebview?.callHandler) {
            // If the flutter bridge isn't available, fail gracefully
            return [];
          }

          const result = await window.flutter_inappwebview.callHandler('curlRequest', {
            url,
            method: 'GET',
            runInIsolate: true
          });

          // curlRequest returns: { data: base64(utf8(response.data)), statusCode }
          const text = decodeBase64UTF8(result?.data || "");
          if (!text) return [];
          return this.parseSuggestions(text);
        } catch {
          return [];
        }
      }
    }

    class GoogleSearch {
      // --- Helpers ---
      _ensureBridge() {
        if (!window.flutter_inappwebview?.callHandler) {
          throw new Error('BRIDGE_MISSING: flutter_inappwebview not available');
        }
        if (typeof decodeBase64UTF8 !== 'function') {
          throw new Error('B64_DECODER_MISSING: decodeBase64UTF8 is not defined');
        }
      }

      _decodeResponse(res) {
        if (!res || typeof res.statusCode !== 'number') {
          throw new Error('NO_STATUS');
        }
        // (Optional) check for non-2xx if your bridge provides status codes
        // if (res.statusCode < 200 || res.statusCode >= 300) {
        //   throw new Error(`HTTP_${res.statusCode}`);
        // }
        const text = decodeBase64UTF8(res.data || '');
        if (!text) throw new Error('EMPTY_BODY');
        return text;
      }

      _extractOptsObject(jsText) {
        // The script is an IIFE like: (function(opts_){ ... })( { ... } );
        // Grab the final object literal passed to the IIFE.
        const m = jsText.match(/\}\)\(\s*({[\s\S]*?})\s*\);?/);
        if (!m) return null;
        const candidate = m[1];

        // In current payload it’s already valid JSON (double-quoted keys/strings).
        // But guard in case minification adds stray trailing commas (basic cleanup).
        const cleaned = candidate
          // remove trailing commas before } or ]
          .replace(/,\s*([}\]])/g, '$1');

        try {
          return JSON.parse(cleaned);
        } catch {
          // Fallback: targeted regex extraction if parsing fails.
          const token = (jsText.match(/"cse_token"\s*:\s*"([^"]+)"/) || [])[1] || '';
          const cselibVersion = (jsText.match(/"cselibVersion"\s*:\s*"([^"]+)"/) || [])[1] || '';
          const expRaw = (jsText.match(/"exp"\s*:\s*\[([\s\S]*?)\]/) || [])[1] || '';
          const exp = expRaw
            ? expRaw.split(',').map(s => s.replace(/[\s"']/g, '')).filter(Boolean)
            : [];
          return { cse_token: token, cselibVersion, exp };
        }
      }

      // --- Main: fetch & extract from Google CSE bootstrap ---
      async setInitVariable(baseUrl) {
        try {
          this._ensureBridge();

          // Build the URL. If baseUrl is provided, use it as origin; otherwise use the default endpoint.
          // Example: baseUrl = 'https://cse.google.com/'
          let jsUrl = 'https://cse.google.com/cse.js?cx=50c5ac9923f4a4b9b';
          if (baseUrl) {
            try {
              jsUrl = new URL('cse.js?cx=50c5ac9923f4a4b9b', baseUrl).toString();
            } catch {
              // If baseUrl is malformed, fall back to default
            }
          }

          const raw = await window.flutter_inappwebview.callHandler('curlRequest', {
            url: jsUrl,
            method: 'GET',
            runInIsolate: true,
          });

          const body = this._decodeResponse(raw);
          const opts = this._extractOptsObject(body) || {};

          const cse_token_for_google_search = opts.cse_token || '';
          const exp_for_google_search = Array.isArray(opts.exp) ? opts.exp : [];
          const cselibVersion_for_google_search = opts.cselibVersion || '';

          return {
            cse_token_for_google_search,
            exp_for_google_search,
            cselibVersion_for_google_search,
          };
        } catch {
          return {
            cse_token_for_google_search: '',
            exp_for_google_search: [],
            cselibVersion_for_google_search: '',
          };
        }
      }

      // ---- Search (Google CSE) ----
      async search(options) {
        // small helpers local to this method
        const safeJsonParse = (s) => { try { return JSON.parse(s || '{}'); } catch { return {}; } };
        const ensureBridge = () => {
          if (!window.flutter_inappwebview?.callHandler) {
            throw new Error('BRIDGE_MISSING: flutter_inappwebview not available');
          }
          if (typeof decodeBase64UTF8 !== 'function') {
            throw new Error('B64_DECODER_MISSING: decodeBase64UTF8 is not defined');
          }
        };
        const decodeBody = (res) => {
          if (!res) throw new Error('NO_RESPONSE');
          const txt = decodeBase64UTF8(res.data || '');
          if (!txt) throw new Error('EMPTY_BODY');
          return txt;
        };
        const buildUrl = (params) => {
          const u = new URL('https://cse.google.com/cse/element/v1');
          Object.entries(params).forEach(([k, v]) => {
            if (v === undefined || v === null) return;
            // arrays (exp) -> comma-separated
            if (Array.isArray(v)) u.searchParams.set(k, v.join(','));
            else u.searchParams.set(k, String(v));
          });
          u.searchParams.set('_', Date.now().toString()); // cache buster
          return u.toString();
        };
        const parseJsonp = (text) => {
          // Matches: google.search.cse.apiNNNNN({...});
          const m = text.match(/google\.search\.cse\.\w+\s*\(\s*([\s\S]*?)\s*\)\s*;?\s*$/);
          if (!m) return null;
          const jsonStr = m[1]
            // strip any trailing commas just in case
            .replace(/,\s*([}\]])/g, '$1');
          try { return JSON.parse(jsonStr); } catch { return null; }
        };

        try {
          ensureBridge();

          const query = (options?.query ?? '').toString().trim();
          const searchSiteModelData = safeJsonParse(options?.searchSiteModel) || {};
          const globalVariablesData = safeJsonParse(options?.globalVariables) || {};

          const CSE_LIB = (globalVariablesData.cselibVersion_for_google_search || '').trim();
          const CSE_TOKEN = (globalVariablesData.cse_token_for_google_search || '').trim();
          // exp can be array or string; normalize to array of strings
          const expArr = Array.isArray(globalVariablesData.exp_for_google_search)
            ? globalVariablesData.exp_for_google_search.map(String)
            : (globalVariablesData.exp_for_google_search ? String(globalVariablesData.exp_for_google_search).split(',') : []);

          if (!CSE_LIB || !CSE_TOKEN) {
            throw new Error('CONFIG_MISSING: cselibVersion_for_google_search or cse_token_for_google_search');
          }

          const params = {
            rsz: 'filtered_cse',
            num: '100',
            hl: 'en',
            cselibv: CSE_LIB,
            cx: '50c5ac9923f4a4b9b',
            q: query,
            safe: 'active',
            cse_tok: CSE_TOKEN,
            exp: expArr, // will be joined with commas
            callback: 'google.search.cse.api18151',
            rurl: 'https://www.dedigger.com/#gsc.tab=0',
          };

          const urlStr = buildUrl(params);

          const result = await window.flutter_inappwebview.callHandler('curlRequest', {
            url: urlStr,
            method: 'GET',
            runInIsolate: true,
          });

          const body = decodeBody(result);
          const parsed = parseJsonp(body);
          const items = Array.isArray(parsed?.results) ? parsed.results : [];

          const site = searchSiteModelData.siteTitle || 'GoogleSearch';
          const parentSite = searchSiteModelData.primarySource || 'https://cse.google.com';
          const source = searchSiteModelData.key || 'googlesearch';

          const out = [];
          for (const it of items) {
            const name = it?.titleNoFormatting || it?.title || '';
            const unescapedUrl = it?.unescapedUrl || '';
            const clicktrackUrl = it?.clicktrackUrl || '';
            const altUrl = it?.url || '';
            const description = it?.contentNoFormatting || it?.content || '';
            const type = it?.fileFormat || '';

            // magnet should contain unescapedUrl, clicktrackUrl, url (deduped, non-empty)
            const magnet = Array.from(new Set([unescapedUrl, clicktrackUrl, altUrl].filter(Boolean)));

            out.push({
              // TorrentSearchModel fields
              magnet,
              source,
              age: '',          // not available in CSE payload
              name,
              size: '',         // not available in CSE payload
              seeder: '',       // not available in CSE payload
              leecher: '',      // not available in CSE payload
              type,
              site,
              parentSite,
              url: unescapedUrl || altUrl || clicktrackUrl || '',
              trusted: true,
              description,
              nsfw: false,
            });
          }

          return out;
        } catch (e) {
          // align with your other classes: throw a generic error message
          throw new Error('unable to get data');
        }
      }

    }


  </script>
</body>

</html>
